<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>테스트 작성 방법 - The Rust Programming Language</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">The Rust Programming Language</a></li><li class="chapter-item expanded affix "><a href="foreword.html">들어가기에 앞서</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">소개</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> 시작해봅시다</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> 러스트 설치</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, World!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Cargo를 사용해봅시다</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> 추리 게임</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> 일반적인 프로그래밍 개념</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> 변수와 가변성</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> 데이터 타입</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> 함수</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> 주석</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> 흐름 제어문</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> 소유권 이해하기</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> 소유권이 뭔가요?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> 참조자와 Borrow</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> 슬라이스(Slice)</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> 연관된 데이터를 구조체로 구조화하기</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> 구조체 정의 및 인스턴트화</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> 구조체를 사용한 예제 프로그램</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> 메소드 문법</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> 열거형과 패턴 매칭</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> 열거형 정의하기</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> match 흐름 제어 연산자</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> if let을 사용한 간결한 흐름 제어</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> 커져가는 프로젝트를 패키지, 크레이트, 모듈로 관리하기</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> 패키지, 크레이트</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> 모듈을 정의하여 스코프 및 공개 여부 제어하기</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> 경로를 사용해 모듈 트리에서 항목 가리키기</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> use 키워드로 경로를 스코프 내로 가져오기</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> 별개의 파일로 모듈 분리하기</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> 일반적인 컬렉션</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> 벡터에 여러 값을 목록으로 저장하기</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> 문자열에 UTF-8 텍스트를 저장하기</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> 해쉬맵(hash map)에 서로 연관된 키와 값을 저장하기</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> 에러 처리</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> 복구 불가능한 에러에는 panic!!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Result와 함께하는 복구 가능한 에러</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> panic!이냐, panic!이 아니냐, 그것이 문제로다</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> 제네릭 타입, 트레잇, 라이프타임</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> 제네릭 데이터 타입</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> 트레잇으로 공통된 동작을 정의하기</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> 라이프타임으로 참조자의 유효성 검증하기</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> 자동화 테스트 작성하기</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html" class="active"><strong aria-hidden="true">11.1.</strong> 테스트 작성 방법</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> 테스트 실행 제어하기</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> 테스트 조직화</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> An I/O Project: Building a Command Line Program</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Accepting Command Line Arguments</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Reading a File</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Refactoring to Improve Modularity and Error Handling</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Developing the Library’s Functionality with Test Driven Development</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Working with Environment Variables</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Writing Error Messages to Standard Error Instead of Standard Output</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Functional Language Features: Iterators and Closures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Closures: Anonymous Functions that Can Capture Their Environment</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Processing a Series of Items with Iterators</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Improving Our I/O Project</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Comparing Performance: Loops vs. Iterators</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> More about Cargo and Crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Customizing Builds with Release Profiles</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Publishing a Crate to Crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargo Workspaces</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Installing Binaries from Crates.io with cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Extending Cargo with Custom Commands</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Smart Pointers</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Using Box&lt;T&gt; to Point to Data on the Heap</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Treating Smart Pointers Like Regular References with the Deref Trait</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Running Code on Cleanup with the Drop Trait</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, the Reference Counted Smart Pointer</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; and the Interior Mutability Pattern</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Reference Cycles Can Leak Memory</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Fearless Concurrency</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Using Threads to Run Code Simultaneously</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Using Message Passing to Transfer Data Between Threads</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Shared-State Concurrency</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Extensible Concurrency with the Sync and Send Traits</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Object Oriented Programming Features of Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Characteristics of Object-Oriented Languages</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Using Trait Objects That Allow for Values of Different Types</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Implementing an Object-Oriented Design Pattern</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Patterns and Matching</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> All the Places Patterns Can Be Used</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> Refutability: Whether a Pattern Might Fail to Match</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> Pattern Syntax</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Advanced Features</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Unsafe Rust</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> Advanced Traits</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> Advanced Types</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> Advanced Functions and Closures</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> Macros</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Final Project: Building a Multithreaded Web Server</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> Building a Single-Threaded Web Server</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Turning Our Single-Threaded Server into a Multithreaded Server</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> Graceful Shutdown and Cleanup</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Appendix</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - Keywords</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B - Operators and Symbols</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C - Derivable Traits</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> D - Useful Development Tools</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> E - Editions</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> F - Translations of the Book</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G - How Rust is Made and “Nightly Rust”</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="테스트-작성-방법"><a class="header" href="#테스트-작성-방법">테스트 작성 방법</a></h2>
<p>테스트란, 테스트할 코드가 의도대로 기능하는지 검증하는 함수입니다.
테스트 함수는 보통 본문에서 세 가지 동작을
수행합니다.</p>
<ol>
<li>필요한 데이터나 상태 설정</li>
<li>테스트할 코드 실행</li>
<li>의도한 결과가 나오는지 확인</li>
</ol>
<p>러스트는 이 세 가지 동작을 수행하는 테스트를 작성할 때
필요한 기능을 특별히 제공합니다.
<code>test</code> 속성, 몇 가지 매크로, <code>should_panic</code> 속성을 알아봅시다.</p>
<h3 id="테스트-함수-파헤치기"><a class="header" href="#테스트-함수-파헤치기">테스트 함수 파헤치기</a></h3>
<p>간단히 말해서, 러스트에서 테스트란 <code>test</code> 속성이 어노테이션된 함수입니다.
속성은 러스트 코드 일부에 대한 메타데이터입니다.
앞서 5장에서 구조체에 사용한 <code>derive</code> 도 속성 중 하나입니다.
함수의 <code>fn</code> 이전 줄에 <code>#[test]</code>를 추가하면 테스트 함수로 변경됩니다.
테스트는 <code>cargo test</code> 명령어로 실행하며,
테스트를 실행하면 러스트는 <code>test</code> 속성이 붙은 함수를 실행하고
결과를 보고하는 테스트 실행 바이너리를 빌드합니다.</p>
<p>Cargo로 새 라이브러리 프로젝트를 생성하면
테스트 함수가 포함된 테스트 모듈이 자동 생성됩니다.
여러분은 새 프로젝트를 생성할 때마다 정확한 구조 및
테스트 함수 문법을 찾아볼 필요 없이 이 모듈을 참고하면 됩니다.
테스트 모듈, 테스트 함수는 여러분이 원하는 만큼 추가할 수 있습니다!</p>
<p>생성된 테스트 템플릿은 실제로는 아무 코드도 테스트하지 않습니다.
이 테스트를 먼저 살펴보면서 테스트가 어떻게 작동하는지 알아보고 나서,
실제로 우리가 작성한 코드가 제대로 작동하는지 확인하는 테스트를 직접
작성해보겠습니다.</p>
<p><code>adder</code> 라이브러리 프로젝트를 생성해보죠.</p>
<pre><code class="language-console">$ cargo new adder --lib
     Created library `adder` project
$ cd adder
</code></pre>
<p><code>adder</code> 라이브러리의 <em>src/lib.rs</em> 파일 내용은
다음과 같습니다.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}
</code></pre>
<p><span class="caption">Listing 11-1: <code>cargo new</code> 명령어로 자동 생성된
테스트 모듈과 함수</span></p>
<p>맨 위 두 줄은 무시하고 함수에 집중합시다.
<code>fn</code> 이전 줄에 <code>#[test]</code> 어노테이션이 있는 걸 볼 수 있습니다.
이 속성은 해당 함수가 테스트 함수임을 표시하며, 테스트 실행기는 이 표시를 보고
해당 함수를 테스트로 실행합니다. <code>tests</code> 모듈 내에는 테스트 함수뿐만 아니라, 일반적인 시나리오를
설정하거나 자주 쓰이는 연산을 수행하는 일반 함수도 작성하기도 하므로,
어떤 함수가 테스트 함수인지 <code>#[test]</code> 속성으로 표시해주어야 합니다.</p>
<p>함수 본문에선 <code>assert_eq!</code> 매크로를 사용해 2 + 2가 4 임을 단언(assert)합니다.
이 단언 코드는 일반적인 테스트 형식 예제로서 제공됩니다.
한번 테스트를 실행해 이 테스트가 통과되는지 확인해보죠.</p>
<p><code>cargo test</code> 명령어는 프로젝트 내 모든 테스트를 실행합니다.
결과는 Listing 11-2처럼 나타납니다.</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.57s
     Running target/debug/deps/adder-92948b65e88960b4

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

</code></pre>
<p><span class="caption">Listing 11-2: 자동 생성된 테스트
실행 결과</span></p>
<p>Cargo가 테스트를 컴파일하고 실행했습니다.
<code>Compiling</code>, <code>Finished</code>, <code>Running</code> 줄 이후 <code>running 1 test</code> 줄이 위치합니다.
그다음 줄에는 생성된 테스트 함수의 이름 <code>it_works</code> 와 테스트 실행 결과 <code>ok</code> 가 표시됩니다.
그다음엔 테스트 실행 전체 요약이 나타납니다.
<code>test result: ok.</code> 는 모든 테스트가 통과됐다는 뜻입니다.
부분별로 살펴보면, <code>1 passed; 0 failed</code> 는 각각 통과한/실패한 테스트 개수를 의미합니다.</p>
<p>무시하도록 지정한 테스트는 없었으니, <code>0 ignored</code>로 표시됩니다.
실행할 테스트를 필터링하지도 않았으니 <code>0 filtered out</code>으로 표시됩니다.
테스트 무시 및 필터링 방법은 다음 절인
<a href="ch11-02-running-tests.html#controlling-how-tests-are-run">“Controlling How Tests Are Run.”</a><!-- ignore --> 에서
알아볼 예정입니다.</p>
<p><code>0 measured</code> 통계는 성능 측정 벤치마크 테스트용입니다.
이 내용이 작성된 시점 기준으로, 벤치마크 테스트는 러스트 나이틀리(nightly)에서만 사용 가능합니다.
자세한 내용은 <a href="https://doc.rust-lang.org/stable/unstable-book/library-features/test.html">벤치마크 테스트 문서</a> 를 참고해주세요.</p>
<p>테스트 출력 결과 중 <code>Doc-tests adder</code> 로 시작하는 부분은 문서 테스트 결과를 나타냅니다.
우리는 아직 문서 테스트를 작성해보진 않았지만, 러스트는 우리가 API 문서에 적은
예제 코드도 컴파일 할 수 있습니다. 러스트의 이 기능은 우리가 작성한 코드와
문서의 내용이 달라지지 않도록 유지보수하는 데에 매우 유용하답니다!
문서 테스트 작성 방법은 14 장 <a href="ch14-02-publishing-to-crates-io.html#documentation-comments-as-tests">“Documentation Comments as Tests”</a><!-- ignore -->
에서 배울 예정입니다.
지금은 일단 <code>Doc-tests</code> 출력을 무시하겠습니다.</p>
<p>테스트 이름을 변경해보고 테스트 실행 출력 결과가
어떻게 달라지는지 살펴봅시다.
<code>it_works</code> 함수의 이름을 <code>exploration</code> 로 변경해보죠.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">#[cfg(test)]
mod tests {
    #[test]
    fn exploration() {
        assert_eq!(2 + 2, 4);
    }
}
</code></pre>
<p><code>cargo test</code> 를 다시 실행하면 출력 결과에 <code>it_works</code> 대신
<code>exploration</code> 이 나타납니다.</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.59s
     Running target/debug/deps/adder-92948b65e88960b4

running 1 test
test tests::exploration ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

</code></pre>
<p>다른 테스트를 추가해보겠습니다. 그런데 이번엔 테스트가 실패하도록 만들어보죠!
테스트 함수 내에서 패닉이 발생하면 테스트는 실패합니다.
각각의 테스트는 새로운 스레드에서 실행되며, 메인 스레드에서 테스트 스레드가
죽은 것을 알게 되면 해당 테스트는 실패한 것으로 처리됩니다.
가장 쉽게 패닉을 일으키는 방법은 9장에서 배웠었죠. <code>panic</code> 매크로를 호출합시다.
Listing 11-3처럼 <code>another</code> 라는 테스트를 새로 추가해봅시다.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust panics noplayground">#[cfg(test)]
mod tests {
    #[test]
    fn exploration() {
        assert_eq!(2 + 2, 4);
    }

    #[test]
    fn another() {
        panic!(&quot;Make this test fail&quot;);
    }
}
</code></pre>
<p><span class="caption">Listing 11-3: <code>panic!</code> 매크로를 호출하여 실패하도록 만든
테스트 추가</span></p>
<p><code>cargo test</code>를 다시 실행해보죠. 출력 결과는 Listing 11-4처럼
<code>exploration</code> 테스트는 통과하고 <code>another</code> 테스트는 실패했다고 나타날 겁니다.</p>
<pre><code class="language-text">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.72s
     Running target/debug/deps/adder-92948b65e88960b4

running 2 tests
test tests::another ... FAILED
test tests::exploration ... ok

failures:

---- tests::another stdout ----
thread 'main' panicked at 'Make this test fail', src/lib.rs:10:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::another

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--lib'
</code></pre>
<p><span class="caption">Listing 11-4: 테스트 하나는 통과하고 다른 하나는 실패했을 때의
테스트 결과</span></p>
<p><code>test tests::another</code> 줄은 <code>ok</code> 가 아니라 <code>FAILED</code> 로 표시됩니다.
개별 결과와 요약 사이에 새로운 절이 두 개 나타났네요.
첫 번째 절은 테스트가 실패한 자세한 이유를 보여줍니다.
이 경우 <code>another</code> 테스트는 <code>panicked at 'Make this test fail'</code> 라는 이유로 실패했으며,
<em>src/lib.rs</em> 파일 10번째 줄에서 발생했습니다.
다음 절은 실패한 테스트의 이름을 목록으로 보여줍니다.
이는 테스트가 많아지고 테스트 실패 사유 출력 양도 많아졌을 때 유용합니다.
실패한 테스트의 이름을 이용해 해당 테스트만 실행하면 쉽게 디버깅할 수 있습니다.
테스트를 실행하는 각종 방식은 <a href="ch11-02-running-tests.html#controlling-how-tests-are-run">“Controlling How Tests Are Run”</a><!-- ignore --> 절에서
다룰 예정입니다.</p>
<p>요약 줄은 마지막에 출력됩니다. 종합적인 테스트 결과는 <code>FAILED</code> 군요.
테스트 하나는 통과했지만, 테스트 하나를 실패했습니다.</p>
<p>각 상황에서 테스트 실행 결과가 어떻게 나타나는지 살펴봤으니,
<code>panic!</code> 이외에 테스트에서 유용하게 쓰이는 매크로를 알아봅시다.</p>
<h3 id="assert-매크로로-결과-검사하기"><a class="header" href="#assert-매크로로-결과-검사하기"><code>assert!</code> 매크로로 결과 검사하기</a></h3>
<p>어떤 조건이 <code>true</code> 임을 보장하는 테스트를 작성할 땐
표준 라이브러리가 제공하는 <code>assert!</code> 매크로가 유용합니다.
<code>assert!</code> 매크로는 Boolean 값으로 평가되는 인자를 전달받습니다.
<code>true</code> 값일 경우 <code>assert!</code> 매크로는 아무 일도 하지 않아, 테스트는 통과합니다.
<code>false</code> 값일 경우 <code>assert!</code> 매크로는 <code>panic!</code> 매크로를 호출하여, 테스트는 실패합니다.
우리가 작성한 코드가 의도대로 기능하는지 검사할 때 <code>assert!</code> 매크로를 유용하게
사용할 수 있습니다.</p>
<p>5장 Listing 5-15에서 <code>Rectangle</code> 구조체랑 <code>can_hold</code> 메소드를 사용했었죠.
(Listing 11-5로 다시 보여드립니다.)
이 코드를 <em>src/lib.rs</em> 파일에 작성하고 <code>assert!</code> 매크로로 테스트를 작성해봅시다.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}
</code></pre>
<p><span class="caption">Listing 11-5: 5장 <code>Rectangle</code> 구조체와
<code>can_hold</code> 메소드</span></p>
<p><code>can_hold</code> 메소드는 Boolean 값을 반환하니
<code>assert</code> 매크로 사용 예시로 쓰기에 딱 알맞습니다.
Listing 11-6는 <code>can_hold</code> 메소드를 시험하는 테스트를 작성한 모습입니다.
너비 8, 높이 7 <code>Rectangle</code> 인스턴스를 생성하고,
이 인스턴스는 너비 5, 높이 1 <code>Rectangle</code> 인스턴스를 포함할 수 있음을 단언합니다.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Rectangle {
</span><span class="boring">    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
</span><span class="boring">        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn larger_can_hold_smaller() {
        let larger = Rectangle {
            width: 8,
            height: 7,
        };
        let smaller = Rectangle {
            width: 5,
            height: 1,
        };

        assert!(larger.can_hold(&amp;smaller));
    }
}
</code></pre>
<p><span class="caption">Listing 11-6: 큰 사각형이 작은 사각형을 정말로
포함할 수 있는지 검사하는 <code>can_hold</code> 메소드 테스트</span></p>
<p><code>tests</code> 모듈에 <code>use super::*;</code> 줄이 추가되었습니다.
<code>tests</code> 모듈 또한 7장
<a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html">“Paths for Referring to an Item in the Module Tree”</a><!-- ignore -->에서 다룬
가시성 규칙을 따르는 평범한 모듈입니다.
따라서, 내부 모듈인 <code>tests</code> 모듈에서 외부 모듈의 코드를
테스트하려면 먼저 내부 스코프로 가져와야 합니다.
<code>tests</code> 모듈에서는 글롭(<code>*</code>)을 사용해 외부 모듈에
정의된 걸 전부 사용할 수 있도록 하였습니다.</p>
<p>테스트 이름은 <code>larger_can_hold_smaller</code> 로 정하고,
필요한 <code>Rectangle</code> 인스턴스를 두 개 생성하고,
<code>larger.can_hold(&amp;smaller)</code> 호출 결과를 전달하여 <code>assert!</code> 매크로를 호출하였습니다.
<code>larger.can_hold(&amp;smaller)</code> 표현식은 <code>true</code> 를 반환할 테니 테스트는 성공하겠죠. 확인해봅시다!</p>
<pre><code class="language-console">$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished test [unoptimized + debuginfo] target(s) in 0.66s
     Running target/debug/deps/rectangle-6584c4561e48942e

running 1 test
test tests::larger_can_hold_smaller ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests rectangle

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

</code></pre>
<p>통과됐네요! 이번에는 작은 사각형이 큰 사각형을 포함할 수 없음을
단언하는 테스트를 추가해봅시다.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Rectangle {
</span><span class="boring">    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
</span><span class="boring">        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn larger_can_hold_smaller() {
        // --snip--
<span class="boring">        let larger = Rectangle {
</span><span class="boring">            width: 8,
</span><span class="boring">            height: 7,
</span><span class="boring">        };
</span><span class="boring">        let smaller = Rectangle {
</span><span class="boring">            width: 5,
</span><span class="boring">            height: 1,
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        assert!(larger.can_hold(&amp;smaller));
</span>    }

    #[test]
    fn smaller_cannot_hold_larger() {
        let larger = Rectangle {
            width: 8,
            height: 7,
        };
        let smaller = Rectangle {
            width: 5,
            height: 1,
        };

        assert!(!smaller.can_hold(&amp;larger));
    }
}
</code></pre>
<p>이번에는 <code>can_hold</code> 함수가 <code>false</code> 를 반환해야 하니,
<code>assert!</code> 매크로에 전달하기 전에 논리 부정 연산자를 사용했습니다.
결과적으로, 이 테스트는 <code>can_hold</code> 함수에서 <code>false</code> 값을 반환하면 성공합니다.</p>
<pre><code class="language-console">$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished test [unoptimized + debuginfo] target(s) in 0.66s
     Running target/debug/deps/rectangle-6584c4561e48942e

running 2 tests
test tests::larger_can_hold_smaller ... ok
test tests::smaller_cannot_hold_larger ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests rectangle

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

</code></pre>
<p>두 테스트를 모두 통과했습니다! 그럼 이제 코드에 버그가 있으면
테스트 결과가 어떻게 되는지 알아보죠.
<code>can_hold</code> 메소드 구현부 중 너비 비교 부분의
큰 부등호를 작은 부등호로 바꿔봅시다.</p>
<pre><code class="language-rust not_desired_behavior noplayground"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>// --snip--
impl Rectangle {
    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &lt; other.width &amp;&amp; self.height &gt; other.height
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn larger_can_hold_smaller() {
</span><span class="boring">        let larger = Rectangle {
</span><span class="boring">            width: 8,
</span><span class="boring">            height: 7,
</span><span class="boring">        };
</span><span class="boring">        let smaller = Rectangle {
</span><span class="boring">            width: 5,
</span><span class="boring">            height: 1,
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        assert!(larger.can_hold(&amp;smaller));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn smaller_cannot_hold_larger() {
</span><span class="boring">        let larger = Rectangle {
</span><span class="boring">            width: 8,
</span><span class="boring">            height: 7,
</span><span class="boring">        };
</span><span class="boring">        let smaller = Rectangle {
</span><span class="boring">            width: 5,
</span><span class="boring">            height: 1,
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        assert!(!smaller.can_hold(&amp;larger));
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>테스트 실행 결과는 다음과 같습니다.</p>
<pre><code class="language-console">$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished test [unoptimized + debuginfo] target(s) in 0.66s
     Running target/debug/deps/rectangle-6584c4561e48942e

running 2 tests
test tests::larger_can_hold_smaller ... FAILED
test tests::smaller_cannot_hold_larger ... ok

failures:

---- tests::larger_can_hold_smaller stdout ----
thread 'main' panicked at 'assertion failed: larger.can_hold(&amp;smaller)', src/lib.rs:28:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::larger_can_hold_smaller

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--lib'
</code></pre>
<p>테스트로 버그를 찾아냈네요! <code>larger.width</code> 는 8이고 <code>smaller.width</code> 는 5인데
<code>can_hold</code> 의 너비 비교 결과는 <code>false</code> (<code>larger.width</code> 가 <code>smaller.width</code> 보다 작음) 를 반환합니다.
8이 5보다 작진 않죠.</p>
<h3 id="assert_eq-assert_ne-매크로를-이용한-동등-테스트"><a class="header" href="#assert_eq-assert_ne-매크로를-이용한-동등-테스트"><code>assert_eq!</code>, <code>assert_ne!</code> 매크로를 이용한 동등 테스트</a></h3>
<p>기능성 테스트는 일반적으로, 테스트 내 코드 결과 값이
우리가 예상한 값과 같은지 확인하는 방식을 이용합니다.
이는 <code>assert!</code> 매크로에 <code>==</code> 연산자를 사용한 표현식을 전달하는 식으로도 가능하지만,
러스트는 이런 테스트에 더 알맞은 매크로를 따로 제공합니다.
<code>assert_eq!</code>, <code>assert_ne!</code> 매크로는 각각 두 인자를 비교하고
동등한지(equality)/그렇지 않은지(inequality) 판단합니다.
단언 코드가 실패하면 두 값을 출력하여 테스트의
<em>실패 사유</em> 를 더 알기 쉽게 보여줍니다.
<code>assert!</code> 매크로는 <code>==</code> 표현식이 <code>false</code> 값임을 알려줄 뿐,
어떤 값으로 인해 <code>false</code> 값이 나왔는지는 알려주지 않습니다.</p>
<p>Listing 11-7은 매개변수에 <code>2</code> 를 더해 반환하는 <code>add_two</code> 함수를 작성하고
<code>assert_eq!</code> 매크로를 이용해 테스트하는
예제입니다.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub fn add_two(a: i32) -&gt; i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_adds_two() {
        assert_eq!(4, add_two(2));
    }
}
</code></pre>
<p><span class="caption">Listing 11-7: <code>assert_eq!</code> 매크로를 이용한
<code>add_two</code> 함수 테스트</span></p>
<p>테스트를 통과하는지 확인해봅시다!</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.58s
     Running target/debug/deps/adder-92948b65e88960b4

running 1 test
test tests::it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

</code></pre>
<p><code>aasert_eq!</code> 매크로 전달한 첫 번째 인자 <code>4</code>는 <code>add_two(2)</code> 호출 결과와 동등합니다.
출력 중 테스트에 해당하는 줄은 <code>test tests::it_adds_two ... ok</code> 이고,
<code>ok</code> 는 테스트가 통과했다는 뜻이죠!</p>
<p><code>assert_eq!</code> 매크로를 사용하는 테스트가 실패했을 땐 어떤 결과가 나오는지 알아봅시다.
<code>add_two</code> 함수가 <code>3</code> 을 더하도록 구현을 변경하여
버그를 만들어보죠.</p>
<pre><code class="language-rust not_desired_behavior noplayground">pub fn add_two(a: i32) -&gt; i32 {
    a + 3
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn it_adds_two() {
</span><span class="boring">        assert_eq!(4, add_two(2));
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>테스트를 다시 실행해보죠.</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.61s
     Running target/debug/deps/adder-92948b65e88960b4

running 1 test
test tests::it_adds_two ... FAILED

failures:

---- tests::it_adds_two stdout ----
thread 'main' panicked at 'assertion failed: `(left == right)`
  left: `4`,
 right: `5`', src/lib.rs:11:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::it_adds_two

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--lib'
</code></pre>
<p>테스트가 버그를 찾아냈습니다! <code>it_adds_two</code> 테스트가 실패하고,
<code>assertion failed: `(left == right)`</code> 메세지와 <code>left</code>, <code>right</code> 가
각각 <code>4</code>, <code>5</code> 였다는 것을 보여줍니다.
이 메세지로 <code>assert_eq!</code> 의 <code>left</code> 인자는 <code>4</code> 였는데 <code>right</code> 인자(<code>add_two(2)</code>)는
5였다는 내용을 알 수 있기 때문에, 디버깅을 시작하는 데 유용한 도움이 됩니다.</p>
<p>몇몇 프로그래밍 언어, 프레임워크에서는 두 값이 서로 동등함을 단언하는 함수에서
각각의 인자를 <code>expected</code>, <code>actual</code> 라고 지칭하며,
코드를 작성할 때 인자의 순서를 지켜야 합니다.
하지만 러스트에서는 <code>left</code>, <code>right</code> 라고 지칭할 뿐,
예상값과 테스트 코드로 만들어진 값의 순서는 상관없습니다.
테스트 코드를 <code>assert_eq!(add_two(2), 4)</code> 로 작성할 수도 있습니다.
이 경우 실패 메세지는 <code>assertion failed: `(left == right)`</code>,
<code>left</code> 는 <code>5</code>, <code>right</code> 는 <code>4</code> 라는 내용으로 나타납니다.</p>
<p><code>assert_ne!</code> 매크로는 전달한 두 값이 서로 같지 않으면 통과하고, 동등하면 실패합니다.
<em>어떤 값이 될지</em> 는 확신할 수 없지만,
적어도 <em>이 값은 될 수 없음</em> 을 알고 있는 경우에 유용합니다.
예를 들어, 테스트할 함수가 입력값을 어떤 방식으로든 변경한다는 것은 확실하지만,
테스트를 실행하는 요일에 따라 함수의 입력값이 달라진다면,
'입력값과 함수 출력이 동일하면 안 된다'고 테스트를 작성하는 게
가장 좋을 겁니다.</p>
<p><code>assert_eq!</code>, <code>assert_ne</code> 매크로는
각각 내부에서 <code>==</code>, <code>!=</code> 연산자를 사용합니다.
단언에 실패할 경우, 매크로는 인자를 디버그 포매팅으로 출력합니다.
즉, <code>assert_eq!</code>, <code>assert_ne</code> 매크로로 비교할 값은
<code>PartialEq</code>, <code>Debug</code> 트레잇을 구현해야 합니다.
모든 기본 타입 및 대부분의 표준 라이브러리 타입은 이 두 트레잇을 구현합니다.
여러분이 정의한 구조체나 열거형에는 여러분이 <code>PartialEq</code> 트레잇을 구현하여 단언 시 값이 서로 같은지,
다른지 알 수 있도록 해야 하고, <code>Debug</code> 트레잇을 구현하여 단언 실패 시 출력될 수 있도록 해야 합니다.
5장 Listing 5-12에서 설명했듯 두 트레잇 모두 derive 가능한 트레잇이기 때문에,
구조체, 열거형 정의에 <code>#[derive(PartialEq, Debug)]</code>를 어노테이션하는것이 일반적입니다.
이에 대한 추가 내용 및 derive 가능한 나머지 트레잇은
부록 C <a href="appendix-03-derivable-traits.html">“Derivable Traits,”</a><!-- ignore -->를 참고해주세요.</p>
<h3 id="커스텀-실패-메시지-추가하기"><a class="header" href="#커스텀-실패-메시지-추가하기">커스텀 실패 메시지 추가하기</a></h3>
<p><code>assert!</code>, <code>assert_eq!</code>, <code>assert_ne!</code> 매크로에
추가 인자로 실패 메세지에 출력될 내용을 추가할 수 있습니다.
<code>assert!</code> 매크로에서 필수적인 인자 하나, <code>assert_eq!</code>, <code>assert_ne!</code>에서
인자 두 개 이후의 인자는 <code>format!</code> 매크로로 전달됩니다.
(<code>format!</code> 매크로는 8장의
<a href="ch08-02-strings.html#-%EC%97%B0%EC%82%B0%EC%9E%90%EB%82%98-format-%EB%A7%A4%ED%81%AC%EB%A1%9C%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%A0%91%ED%95%A9">&quot;<code>+</code> 연산자나 <code>format!</code> 매크로를 이용한 접합&quot;</a><!-- ignore --> 에서 다루었습니다.)
여러분은 <code>{}</code> placeholder를 갖는 포맷 문자열과
placeholder에 해당하는 값을 전달할 수 있습니다.
커스텀 메세지는 테스트 단언의 의미를 문서화하는 용도로 유용합니다.
테스트가 실패할 경우 코드의 문제점이
무엇인지 알아내기 더 수월해지죠.</p>
<p>예시로, 이름을 불러 사람을 환영하는 함수가 있다고 가정해봅시다.
함수에 전달한 이름이 출력 내에 존재하는지 확인하는 테스트를 작성하고자 합니다.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub fn greeting(name: &amp;str) -&gt; String {
    format!(&quot;Hello {}!&quot;, name)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn greeting_contains_name() {
        let result = greeting(&quot;Carol&quot;);
        assert!(result.contains(&quot;Carol&quot;));
    }
}
</code></pre>
<p>아직 프로그램의 요구 사항이 정해지지 않아서,
분명히 <code>Hello</code> 텍스트 부분이 나중에 변경될 거라고 치죠.
프로그램 요구 사항이 바뀔 때 테스트 코드도 고치고 싶지는 않으니
<code>greeting</code> 함수의 정확한 반환 값을 검사하는 대신,
출력 값에 입력 매개변수로 전달한 텍스트가 포함되어있는지만
확인할겁니다.</p>
<p>테스트 실패 시 출력을 살펴보기 위해, <code>greeting</code> 함수 결과 값이
<code>name</code>을 포함하지 않도록 바꾸어 버그를 만들어보았습니다.</p>
<pre><code class="language-rust not_desired_behavior noplayground">pub fn greeting(name: &amp;str) -&gt; String {
    String::from(&quot;Hello!&quot;)
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn greeting_contains_name() {
</span><span class="boring">        let result = greeting(&quot;Carol&quot;);
</span><span class="boring">        assert!(result.contains(&quot;Carol&quot;));
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>테스트 결과는 다음과 같습니다.</p>
<pre><code class="language-console">$ cargo test
   Compiling greeter v0.1.0 (file:///projects/greeter)
    Finished test [unoptimized + debuginfo] target(s) in 0.91s
     Running target/debug/deps/greeter-170b942eb5bf5e3a

running 1 test
test tests::greeting_contains_name ... FAILED

failures:

---- tests::greeting_contains_name stdout ----
thread 'main' panicked at 'assertion failed: result.contains(&quot;Carol&quot;)', src/lib.rs:12:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::greeting_contains_name

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--lib'
</code></pre>
<p>출력 결과는 단언이 실패했다는 것과
몇 번째 줄에서 실패했는지만 표시합니다.
실패 메시지에서 <code>greeting</code> 함수의 반환 값을 출력해주면 더 유용하겠죠.
테스트 함수를 바꾸어 커스텀 실패 메세지를 작성해봅시다.
<code>greeting</code> 함수 반환 값으로 채워질 placeholder를 갖는 포맷 문자열을 작성해보죠.</p>
<pre><code class="language-rust ignore"><span class="boring">pub fn greeting(name: &amp;str) -&gt; String {
</span><span class="boring">    String::from(&quot;Hello!&quot;)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span>    #[test]
    fn greeting_contains_name() {
        let result = greeting(&quot;Carol&quot;);
        assert!(
            result.contains(&quot;Carol&quot;),
            &quot;Greeting did not contain name, value was `{}`&quot;,
            result
        );
    }
<span class="boring">}
</span></code></pre>
<p>이제 에러 메세지를 보고 더 많은 정보를 얻을 수 있습니다. 테스트를 다시 실행해보죠.</p>
<pre><code class="language-console">$ cargo test
   Compiling greeter v0.1.0 (file:///projects/greeter)
    Finished test [unoptimized + debuginfo] target(s) in 0.93s
     Running target/debug/deps/greeter-170b942eb5bf5e3a

running 1 test
test tests::greeting_contains_name ... FAILED

failures:

---- tests::greeting_contains_name stdout ----
thread 'main' panicked at 'Greeting did not contain name, value was `Hello!`', src/lib.rs:12:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::greeting_contains_name

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--lib'
</code></pre>
<p>실제 테스트 결과 값을 볼 수 있으니 우리가 의도했던 것에서
무엇이 달라졌는지 알 수 있어, 디버깅하는 데 도움이 됩니다.</p>
<h3 id="should_panic-매크로로-패닉-발생-검사하기"><a class="header" href="#should_panic-매크로로-패닉-발생-검사하기"><code>should_panic</code> 매크로로 패닉 발생 검사하기</a></h3>
<p>작성한 코드가 정확한 값을 반환하는지 검사하는 것 못지않게,
코드가 에러를 잘 처리하는지 검사하는 것도 중요합니다.
9장 Listing 9-10에서 만들었던 <code>Guess</code> 타입을 생각해보세요.
<code>Guess</code> 타입을 사용하는 다른 코드는 <code>Guess</code> 인스턴스가
1에서 100사이 값만 갖는다는 보장에 의존적입니다.
이런 경우, 범위를 벗어난 값으로 <code>Guess</code> 인스턴스를 만들면
패닉이 발생하는지 검사하는 테스트를 작성하면 확실하게 보장할 수 있습니다.</p>
<p>패닉 검사 테스트 함수에는 <code>should_panic</code> 속성을 추가해야 합니다.
이 속성이 붙은 함수는 내부에서 패닉이 발생해야 테스트를 통과하고,
패닉이 발생하지 않으면 테스트를 실패합니다.</p>
<p>Listing 11-8은 <code>Guess::new</code>의 에러 조건이 의도대로 작동하는지
검사하는 테스트를 보여줍니다.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub struct Guess {
    value: i32,
}

impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 || value &gt; 100 {
            panic!(&quot;Guess value must be between 1 and 100, got {}.&quot;, value);
        }

        Guess { value }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic]
    fn greater_than_100() {
        Guess::new(200);
    }
}
</code></pre>
<p><span class="caption">Listing 11-8: <code>panic!</code> 발생
테스트</span></p>
<p><code>#[should_panic]</code> 속성은 <code>#[test]</code> 속성과
적용할 함수 사이에 위치시켰습니다.
테스트 성공 시 결과를 살펴봅시다.</p>
<pre><code class="language-console">$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished test [unoptimized + debuginfo] target(s) in 0.58s
     Running target/debug/deps/guessing_game-57d70c3acb738f4d

running 1 test
test tests::greater_than_100 ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests guessing_game

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

</code></pre>
<p>괜찮아 보이네요! 이제 <code>new</code> 함수의 패닉 발생 조건 중 100보다
큰 값일 때의 조건을 지워서 버그를 만들어보죠.</p>
<pre><code class="language-rust not_desired_behavior noplayground"><span class="boring">pub struct Guess {
</span><span class="boring">    value: i32,
</span><span class="boring">}
</span><span class="boring">
</span>// --snip--
impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 {
            panic!(&quot;Guess value must be between 1 and 100, got {}.&quot;, value);
        }

        Guess { value }
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    #[should_panic]
</span><span class="boring">    fn greater_than_100() {
</span><span class="boring">        Guess::new(200);
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>Listing 11-8 테스트를 실행하면 다음과 같이 실패합니다.</p>
<pre><code class="language-console">$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished test [unoptimized + debuginfo] target(s) in 0.62s
     Running target/debug/deps/guessing_game-57d70c3acb738f4d

running 1 test
test tests::greater_than_100 ... FAILED

failures:

---- tests::greater_than_100 stdout ----
note: test did not panic as expected

failures:
    tests::greater_than_100

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--lib'
</code></pre>
<p>에러 메세지는 그다지 유용하지 않지만,
테스트 함수를 살펴보면 <code>#[should_panic]</code>으로 어노테이션된 함수라는 걸 알 수 있습니다.
즉, 테스트 함수에서 패닉이 발생하지 않아서 실패했다는 뜻이죠.</p>
<p><code>should_panic</code> 테스트는 단순히 코드에서
패닉이 발생했다는 것만 나타내기 때문에 정확하지 않을 수도 있습니다.
만약 우리가 의도한 것과는 다른 이유로 패닉이 발생하더라도 테스트를 통과합니다.
<code>should_panic</code> 속성에 <code>expected</code> 매개변수를 추가해,
포함되어야 하는 실패 메세지를 지정하면
더 꼼꼼한 <code>should_panic</code> 테스트를 작성할 수 있습니다.
Listing 11-9는 <code>new</code> 함수에서 값이 너무 작은 경우와 큰 경우에
서로 다른 메세지로 <code>panic!</code>을 발생시키도록 수정한 <code>Guess</code> 코드입니다.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground"><span class="boring">pub struct Guess {
</span><span class="boring">    value: i32,
</span><span class="boring">}
</span><span class="boring">
</span>// --snip--
impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 {
            panic!(
                &quot;Guess value must be greater than or equal to 1, got {}.&quot;,
                value
            );
        } else if value &gt; 100 {
            panic!(
                &quot;Guess value must be less than or equal to 100, got {}.&quot;,
                value
            );
        }

        Guess { value }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic(expected = &quot;Guess value must be less than or equal to 100&quot;)]
    fn greater_than_100() {
        Guess::new(200);
    }
}
</code></pre>
<p><span class="caption">Listing 11-9: 특정 메세지를 포함하는
<code>panic!</code> 발생 테스트</span></p>
<p><code>should_panic</code> 속성의 <code>expected</code> 매개변수 값이
<code>Guess::new</code> 함수에서 발생한 패닉 메세지 문자열의 일부이므로 테스트는 통과합니다.
발생해야 하는 패닉 메세지 전체를 명시할 수도 있습니다.
이 경우 <code>Guess value must be less than or equal to 100, got 200.</code> 가 되겠죠.
<code>expected</code> 매개변수에 명시할 내용은 패닉 메세지의
고유성, 유동성, 테스트에 요구되는 정확성에 따라 달라집니다.
이번 경우에는, 패닉 메세지 문자열 일부만으로도 실행된 함수 코드가
<code>else if value &gt; 100</code> 상황에 해당함을 확신할 수 있으니
충분합니다.</p>
<p><code>expected</code> 메세지를 명시한 <code>should_panic</code> 테스트가 실패하면 어떻게 되는지 알아보죠.
<code>if value &lt; 1</code> 코드 단락과 <code>else if value &gt; 100</code> 코드 단락을 서로 바꾸어
버그를 만들어보았습니다.</p>
<pre><code class="language-rust ignore not_desired_behavior"><span class="boring">pub struct Guess {
</span><span class="boring">    value: i32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Guess {
</span><span class="boring">    pub fn new(value: i32) -&gt; Guess {
</span>        if value &lt; 1 {
            panic!(
                &quot;Guess value must be less than or equal to 100, got {}.&quot;,
                value
            );
        } else if value &gt; 100 {
            panic!(
                &quot;Guess value must be greater than or equal to 1, got {}.&quot;,
                value
            );
        }
<span class="boring">
</span><span class="boring">        Guess { value }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    #[should_panic(expected = &quot;Guess value must be less than or equal to 100&quot;)]
</span><span class="boring">    fn greater_than_100() {
</span><span class="boring">        Guess::new(200);
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>이번에는 <code>should_panic</code> 테스트가 실패합니다.</p>
<pre><code class="language-console">$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished test [unoptimized + debuginfo] target(s) in 0.66s
     Running target/debug/deps/guessing_game-57d70c3acb738f4d

running 1 test
test tests::greater_than_100 ... FAILED

failures:

---- tests::greater_than_100 stdout ----
thread 'main' panicked at 'Guess value must be greater than or equal to 1, got 200.', src/lib.rs:13:13
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
note: panic did not contain expected string
      panic message: `&quot;Guess value must be greater than or equal to 1, got 200.&quot;`,
 expected substring: `&quot;Guess value must be less than or equal to 100&quot;`

failures:
    tests::greater_than_100

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--lib'
</code></pre>
<p>테스트에서 패닉이 발생하긴 했지만,
지정한 <code>'Guess value must be less than or equal to 100'</code> 문자열이
패닉 메세지에 포함되어 있지 않다는 것을 알려줍니다.
실제로 발생한 패닉 메세지는 <code>Guess value must be greater than or equal to 1, got 200.</code> 입니다.
이제 우린 이 메세지를 단서로 버그를 찾아낼 수 있습니다!</p>
<h3 id="resultt-e-를-이용한-테스트"><a class="header" href="#resultt-e-를-이용한-테스트"><code>Result&lt;T, E&gt;</code> 를 이용한 테스트</a></h3>
<p>여태까지는 실패 시 패닉을 발생시키는 테스트만 작성했습니다. 테스트는
<code>Result&lt;T, E&gt;</code> 를 사용해 작성할 수도 있습니다. 다음은 Listing 11-1 테스트를
<code>Result&lt;T, E&gt;</code>를 사용하도록 수정한 예시입니다. 패닉을 발생시키는 대신 <code>Err</code> 을 반환합니다.</p>
<pre><code class="language-rust noplayground">#[cfg(test)]
mod tests {
    #[test]
    fn it_works() -&gt; Result&lt;(), String&gt; {
        if 2 + 2 == 4 {
            Ok(())
        } else {
            Err(String::from(&quot;two plus two does not equal four&quot;))
        }
    }
}
</code></pre>
<p><code>it_works</code> 함수는 <code>Result&lt;(), String&gt;</code> 타입을 반환합니다.
함수 본문에서는 <code>assert_eq!</code> 매크로를 호출하는 대신,
테스트 성공 시에는 <code>Ok(())</code> 를 반환하고 실패 시에는 <code>String</code> 을 갖는 <code>Err</code> 를
반환힙니다.</p>
<p><code>Result&lt;T, E&gt;</code>를 반환하는 테스트에선 <code>?</code> 연산자를 사용할 수 있기 때문에,
내부 작업이 <code>Err</code> 를 반환할 경우 실패해야 하는 테스트를 작성하기
편리합니다.</p>
<p><code>Result&lt;T, E&gt;</code> 테스트에서는
<code>#[should_panic]</code> 어노테이션을 사용할 수 없습니다.
실패해야 하는 테스트는 <code>Err</code> 값을 직접 반환해야 합니다.</p>
<p>여러 테스트 작성 방법을 배웠으니,
우리가 테스트를 실행할 때 어떤 일들이 일어나는지 알아보고
<code>cargo test</code> 명령어 옵션을 살펴봅시다.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch11-00-testing.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="ch11-02-running-tests.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch11-00-testing.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="ch11-02-running-tests.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="ferris.js"></script>
    </body>
</html>
